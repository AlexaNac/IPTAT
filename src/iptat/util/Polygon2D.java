package iptat.util;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Point2D.Double;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;

public class Polygon2D implements Subject {
	
	private final static double RADIUS = 6;
	
	private List<Observer> observers;
	
	private LinkedList<Point2D.Double> points;
	private LinkedList<Line2D.Double> edges;
	private Stack<Point2D.Double> redoPoints;
	private Stack<Line2D.Double> redoEdges;
	private HashSet<Point2D.Double> pointsHash;
	
	private LinkedList<LinkedList<Point2D.Double>> triangles;
	
	public Polygon2D() {
		observers = new ArrayList<Observer>();
		points = new LinkedList<Point2D.Double>();
		edges = new LinkedList<Line2D.Double>();
		redoPoints = new Stack<Point2D.Double>();
		redoEdges = new Stack<Line2D.Double>();
		pointsHash = new HashSet<Point2D.Double>();
		
		triangles = null;
	}
	
	public void addPoint(Point2D.Double point) {
		if (pointsHash.contains(point))
			return;
		
		if (points.size() >= 1) // we need at least 2 points to begin construction of edges list
			edges.add(new Line2D.Double(points.get(points.size() - 1), point));
		
		points.add(point);
		pointsHash.add(point);
		triangles = null;
		
		notifyObservers(ObserverConstants.DRAWBOARD_REPAINT);
		
		redoPoints.clear();
		redoEdges.clear();
	}
	
	public void addPoint(double x, double y) {
		Point2D.Double point = new Point2D.Double(x, y);
		addPoint(point);
	}
	
	// removes the last added point
	public boolean removeLast() {
		if (!points.isEmpty()) {
			pointsHash.remove(points.getLast());
			redoPoints.push(points.removeLast());
			if (!edges.isEmpty())
				redoEdges.push(edges.removeLast());
			
			triangles = null;
			notifyObservers(ObserverConstants.DRAWBOARD_REPAINT);
			return true;
		}
		
		return false;
	}
	
	// restores the last removed point
	public boolean restoreLast() {
		if (!redoPoints.empty()) {
			points.add(redoPoints.pop());
			
			if (points.size() > 1)
				edges.add(redoEdges.pop());
			
			triangles = null;
			notifyObservers(ObserverConstants.DRAWBOARD_REPAINT);
			return true;
		}
		
		return false;
	}
	
	public void clear() {
		while (!points.isEmpty())
			removeLast();
		pointsHash.clear();
		triangles = null;
		
		notifyObservers(ObserverConstants.DRAWBOARD_REPAINT);
	}
	
	public LinkedList<Point2D.Double> getPointsList() {
		return points;
	}
	
	public LinkedList<Line2D.Double> getEdgesList() {
		return edges;
	}
	
	public int getPointsCount() {
		return points.size();
	}
	
	public boolean isTriangulated() {
		return triangles != null;
	}
	
	public void setTriangulation(LinkedList<LinkedList<Point2D.Double>> triangles) {
		this.triangles = triangles;
		notifyObservers(ObserverConstants.DRAWBOARD_REPAINT);
	}
	
	public void draw(Graphics2D g) {
		// draw edges
		for (Line2D.Double edge: edges)
			g.draw(edge);
		
		// emphasize points by drawing circles centered on them
		for (Point2D.Double point: points)
			g.fill(new Ellipse2D.Double(point.getX() - RADIUS / 2,
					point.getY() - RADIUS / 2, RADIUS, RADIUS));
		
		// draw a line between the first point and the last
		if (points.size() >= 3) {
			int lastIndex = points.size() - 1;
			g.draw(new Line2D.Double(points.get(lastIndex), points.get(0)));
		}
		
		// draw the diagonals generated by triangulation
		drawDiagonals(g);
	}
	
	private void drawDiagonals(Graphics2D g) {
		if (triangles == null)
			return;
		
		Color lastColor = g.getColor();
		g.setColor(Color.RED);
		
		Iterator<LinkedList<Point2D.Double>> it = triangles.iterator();
		LinkedList<Point2D.Double> triangle = it.next();
		
		/* ignore the last triangle as it should contain either a diagonal which is already drawn
		 * or a polygon edge
		 */
		while (it.hasNext()) {
			g.draw(new Line2D.Double(triangle.getFirst().getX(), triangle.getFirst().getY(),
					triangle.getLast().getX(), triangle.getLast().getY()));
			triangle = it.next();
		}
		
		g.setColor(lastColor);
	}

	@Override
	public void addObserver(Observer ob) {
		observers.add(ob);
	}

	@Override
	public void removeObserver(Observer ob) {
		int index = observers.indexOf(ob);
		if (index != -1)
			observers.remove(index);
	}

	@Override
	public void notifyObservers(int state) {
		for (Observer ob: observers)
			ob.update(state);
	}
}
